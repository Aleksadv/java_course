# Реализация алгоритма Хаффмана для сжатия данных

## О проекте

Данный проект представляет собой реализацию алгоритма Хаффмана на языке Java для сжатия и распаковки файлов. Алгоритм Хаффмана — это алгоритм энтропийного сжатия, который использует переменную длину кода для кодирования символов: более частые символы получают более короткие коды, а менее частые — более длинные.

## Содержание
1. [Требования к системе](#требования-к-системе)
2. [Сборка и запуск](#сборка-и-запуск)
3. [Использование](#использование)
4. [Формат закодированного файла](#формат-закодированного-файла)
5. [Тестовые примеры](#тестовые-примеры)
6. [Результаты тестирования](#результаты-тестирования)
7. [Структура проекта](#структура-проекта)
8. [Особенности реализации](#особенности-реализации)
9. [Заключение](#заключение)

## Требования к системе

- **Java Development Kit (JDK)** версии 8 или выше
- **Командная строка** (терминал) для запуска программы

## Сборка и запуск

### 1. Компиляция программы

```bash
javac HuffmanCoding.java
```

После успешной компиляции будет создан файл `HuffmanCoding.class`.

### 2. Запуск программы

Программа управляется через командную строку:

```bash
java HuffmanCoding <команда> <аргументы>
```

## Использование

### Основные команды

#### 1. Создание тестовых файлов
```bash
java HuffmanCoding -test
```
Создает три тестовых файла в текущей директории:
- `test1.txt` — 10 одинаковых символов '1'
- `test2.txt` — 20 символов: 10x'1', 5x'2', 5x'3'
- `test3.bin` — копия исходного кода программы (бинарный файл)

#### 2. Кодирование (сжатие) файла
```bash
java HuffmanCoding -e <входной_файл> <выходной_файл>
```
Примеры:
```bash
java HuffmanCoding -e test1.txt encoded1.huf
java HuffmanCoding -e document.txt compressed.huf
```

#### 3. Декодирование (распаковка) файла
```bash
java HuffmanCoding -d <закодированный_файл> <раскодированный_файл>
```
Примеры:
```bash
java HuffmanCoding -d encoded1.huf decoded1.txt
java HuffmanCoding -d compressed.huf original.txt
```

### Пример полного рабочего цикла
```bash
# Создание тестовых файлов
java HuffmanCoding -test

# Кодирование файла
java HuffmanCoding -e test1.txt encoded1.huf

# Декодирование файла
java HuffmanCoding -d encoded1.huf decoded1.txt

# Проверка целостности
diff test1.txt decoded1.txt
```

## Формат закодированного файла

Закодированный файл (расширение `.huf`) имеет компактную структуру, содержащую только таблицу кодирования и сжатые данные.

### Структура файла

```
┌────────────┬──────────────────────────┬─────────────────┬─────────────────┐
│ 1 байт     │ Таблица кодов            │ 4 байта         │ Закодированные  │
│ Количество │ [символ(1) + длина(1) +  │ Длина данных    │ данные          │
│ символов   │ код(биты)]               │ в битах         │ (биты)          │
└────────────┴──────────────────────────┴─────────────────┴─────────────────┘
```

### Подробное описание

#### 1. Количество символов (1 байт)
- Беззнаковое число от 0 до 255
- Определяет размер таблицы кодирования

#### 2. Таблица кодов Хаффмана (переменная длина)
Для каждого символа в таблице:
- **Символ (1 байт)**: исходный байт
- **Длина кода (1 байт)**: количество бит в коде (1-255)
- **Код (переменная длина)**: последовательность битов, представляющая код Хаффмана
  - Код хранится побитово, выровненный по байтам
  - Если длина кода не кратна 8, остаток дополняется нулями

#### 3. Длина закодированных данных (4 байта)
- 32-битное целое число в формате big-endian
- Определяет точное количество бит в закодированных данных

#### 4. Закодированные данные (переменная длина)
- Битовый поток, представляющий сжатые данные
- Каждый символ исходного файла заменен соответствующим кодом из таблицы
- Данные выровнены по байтам (дополнение нулями в конце при необходимости)

### Пример для файла "abracadabra"

Предположим, мы имеем коды:
- a: `0`
- b: `10`
- r: `110`
- c: `1110`
- d: `1111`

#### Двоичное представление:
```
00000101 01100001 00000001 00000000 01100010 00000010 10000000 01110010 
00000011 11000000 01100011 00000100 11100000 01100100 00000100 11110000
00000000 00000000 00000000 00101101 01011010 ...
```

#### Разбор:
1. `00000101` = 5 символов в таблице
2. Таблица:
   - `01100001` = символ 'a'
   - `00000001` = длина кода 1
   - `00000000` = код "0"
   - ... (остальные символы)
3. `00000000 00000000 00000000 00101101` = 45 бит закодированных данных
4. `01011010 ...` = закодированные данные

## Тестовые примеры

### Тест 1: Файл с повторяющимися символами
**Имя файла:** `test1.txt`  
**Содержимое:** `1111111111` (10 символов '1')  
**Цель:** Проверить эффективность сжатия при минимальной энтропии

### Тест 2: Файл с тремя различными символами
**Имя файла:** `test2.txt`  
**Содержимое:** `11111111112222233333` (20 символов: 10x'1', 5x'2', 5x'3')  
**Цель:** Проверить работу с простым распределением частот

### Тест 3: Бинарный файл
**Имя файла:** `test3.bin`  
**Содержимое:** Копия исходного кода программы  
**Цель:** Проверить работу с реальными данными различного типа

## Результаты тестирования

### Пример вывода программы

#### Тест 1:
```bash
PS C:\project> java HuffmanCoding -e test1.txt encoded1.huf
Файл закодирован: test1.txt -> encoded1.huf
Исходный размер: 10 байт
Сжатый размер: 10 байт
Коэффициент сжатия: 1,00
Экономия: 0,0%

Таблица кодов Хаффмана:
  '1' -> 0
```

#### Тест 2:
```bash
PS C:\project> java HuffmanCoding -e test2.txt encoded2.huf
Файл закодирован: test2.txt -> encoded2.huf
Исходный размер: 20 байт
Сжатый размер: 18 байт
Коэффициент сжатия: 0,90
Экономия: 10,0%

Таблица кодов Хаффмана:
  '1' -> 0
  '2' -> 10
  '3' -> 11
```

#### Тест 3:
```bash
PS C:\project> java HuffmanCoding -e test3.bin encoded3.huf
Файл закодирован: test3.bin -> encoded3.huf
Исходный размер: 15375 байт
Сжатый размер: 9696 байт
Коэффициент сжатия: 0,63
Экономия: 36,9%

Таблица кодов: 138 символов
```

### Анализ результатов

| Тестовый файл | Исходный размер | Сжатый размер | Коэффициент сжатия | Экономия |
|---------------|-----------------|---------------|-------------------|----------|
| test1.txt     | 10 байт         | 10 байт       | 1.00              | 0%       |
| test2.txt     | 20 байт         | 18 байт       | 0.90              | 10%      |
| test3.bin     | 15375 байт      | 9696 байт     | 0.63              | 37%      |

**Объяснение результатов:**

1. **test1.txt**: Сжатия нет (0%) из-за малого размера файла и накладных расходов на таблицу кодов
2. **test2.txt**: Небольшое сжатие (10%) благодаря сокращению частых символов
3. **test3.bin**: Хорошее сжатие (37%) на реальных данных благодаря алгоритму Хаффмана

## Структура проекта

```
huffman-project/
├── HuffmanCoding.java          # Основной исходный код
├── HuffmanCoding.class         # Скомпилированный класс (после компиляции)
├── README.md                   # Этот файл
├── test1.txt                   # Тестовый файл 1 (после запуска -test)
├── test2.txt                   # Тестовый файл 2 (после запуска -test)
├── test3.bin                   # Тестовый файл 3 (после запуска -test)
└── encoded1.huf                # Пример закодированного файла
```

## Особенности реализации

### Алгоритм работы

#### Кодирование:
1. Чтение исходного файла и подсчет частот символов
2. Построение дерева Хаффмана с использованием приоритетной очереди
3. Генерация префиксных кодов для каждого символа
4. Замена символов на коды и запись в компактном формате

#### Декодирование:
1. Чтение таблицы кодов из закодированного файла
2. Восстановление дерева Хаффмана из таблицы
3. Последовательное чтение битов и обход дерева для восстановления символов

### Ключевые характеристики

 **Компактный формат:** Минимальные накладные расходы, только таблица кодов и данные  
 **Поддержка любых файлов:** Работает с текстовыми и бинарными файлами  
 **Надежность:** Встроенная проверка целостности при декодировании  
 **Информативность:** Подробный вывод статистики сжатия  

### Ограничения

 **Максимальный размер таблицы:** 255 символов (ограничение формата)  
 **Эффективность на малых файлах:** Низкая из-за накладных расходов  
 **Длина кода:** До 255 бит на символ  

### Классы программы

- **`HuffmanNode`**: Представляет узел дерева Хаффмана
- **`HuffmanCoding`**: Основной класс с методами кодирования/декодирования

## Заключение

Данная реализация алгоритма Хаффмана успешно демонстрирует основные принципы энтропийного сжатия данных. Программа:

1.  Корректно реализует алгоритм Хаффмана
2.  Обеспечивает сжатие данных (особенно эффективное на больших файлах)
3.  Имеет удобный интерфейс командной строки
4.  Сохраняет целостность данных при кодировании/декодировании
5.  Предоставляет подробную статистику сжатия

