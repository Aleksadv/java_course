# Разница в работе перегруженных методов

## Ключевая причина различий
Разное поведение возникает из-за **статического разрешения перегрузки** на этапе компиляции.

## Пример с циклом for:
```java
for (Number n : numbers) {
    processor.handleValue(n);  // Тип переменной n - Number (определяется при компиляции)
}

**Что происходит:**

Компилятор анализирует тип переменной n как Number

Выбирается метод handleValue(Number num)

Фактический тип объектов (Integer, Float) игнорируется при выборе метода

##Пример с прямыми вызовами:
java```
processor.handleValue(new Integer(5));  // Компилятор видит Integer → handleValue(Integer i)
processor.handleValue(15);              // Компилятор видит int → handleValue(int i)
processor.handleValue(2.5f);            // Компилятор видит float → handleValue(Float f)
processor.handleValue(7.5);             // Компилятор видит double → handleValue(Number n)
```

**Почему результаты отличаются:**
В цикле:
Тип определяется на этапе компиляции как Number

Всегда вызывается handleValue(Number num)

Вывод будет одинаковым для всех элементов

**В прямых вызовах:**
Компилятор знает точный тип каждого аргумента

Выбирается наиболее подходящий метод для конкретного типа

Вывод различается в зависимости от типа

**Ожидаемый вывод:**
```
// Цикл for - все вызовы handleValue(Number num)
Number value: 5
Number value: 15  
Number value: 2.5
Number value: 7.5

// Прямые вызовы - разные методы
Integer value: 5
int value: 15
Float value: 2.5000
Number value: 7.5
```

**Итог:**
Перегрузка методов разрешается на этапе компиляции на основе объявленных типов параметров, а не фактических типов объектов во время выполнения.